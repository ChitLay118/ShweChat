<!-- feed.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>ShweMyanmar - Feed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="style.css">
</head>
<body>
<nav>
  <div class="container row">
    <div style="font-weight:600">ShweMyanmar</div>
    <div style="margin-left:auto" class="row">
      <button id="profileBtn" class="ghost">Profile</button>
      <button id="chatBtn" class="ghost">Chats</button>
      <button id="adminBtn" class="ghost">Admin</button>
      <button id="logoutBtn" class="ghost">Logout</button>
    </div>
  </div>
</nav>

<div class="container layout">
  <div style="flex:1">
    <div class="center-card">
      <div class="row" style="align-items:flex-start">
        <div class="avatar"></div>
        <div style="flex:1">
          <div class="post-box">
            <textarea id="postText" placeholder="Share something..."></textarea>
            <div style="width:120px">
              <input id="postFiles" type="file" accept="image/*,video/*" multiple>
              <button id="postBtn" style="margin-top:8px">Post</button>
            </div>
          </div>
          <div class="small" id="uploadProgress"></div>
        </div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="story-strip center-card" id="storyStrip">
      <!-- stories go here -->
      <div class="story" id="createStory">
        <div style="font-size:12px">+ Your story</div>
        <input id="storyFile" type="file" accept="image/*,video/*">
      </div>
    </div>

    <div id="feed" class="feed"></div>
  </div>

  <div class="side">
    <div class="center-card">
      <h4>Who to follow</h4>
      <div id="suggestions"></div>
    </div>
    <div style="height:12px"></div>
    <div class="center-card">
      <h4>Notifications</h4>
      <div id="notifications"></div>
    </div>
  </div>
</div>

<script type="module">
import {
  auth, signOut, onAuthStateChanged,
  db, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp,
  storage, ref, uploadBytesResumable, getDownloadURL,
  doc, setDoc, getDoc, updateDoc, where, getDocs, increment
} from './firebase.js';

import { timeAgo } from './utils.js';

const logoutBtn = document.getElementById('logoutBtn');
const profileBtn = document.getElementById('profileBtn');
const chatBtn = document.getElementById('chatBtn');
const adminBtn = document.getElementById('adminBtn');

logoutBtn.addEventListener('click', async ()=>{ await signOut(auth); window.location='index.html'; });
profileBtn.addEventListener('click', ()=> location='profile.html');
chatBtn.addEventListener('click', ()=> location='chat.html');
adminBtn.addEventListener('click', ()=> location='admin.html');

onAuthStateChanged(auth, async user => {
  if(!user) { window.location='index.html'; return; }
  // ensure user doc exists
  await createUserDoc(user);
  loadFeed();
  loadSuggestions(user);
  loadNotifications(user);
});

async function createUserDoc(user){
  const uref = doc(db, 'users', user.uid);
  const snap = await getDoc(uref);
  if(!snap.exists()){
    await setDoc(uref, {
      uid: user.uid,
      email: user.email,
      name: user.displayName || user.email.split('@')[0],
      avatar: '',
      bio: '',
      createdAt: serverTimestamp(),
      followers: 0,
      following: 0,
      isAdmin: false
    });
  }
}

// POST creation (images/videos)
const postBtn = document.getElementById('postBtn');
const postText = document.getElementById('postText');
const postFiles = document.getElementById('postFiles');
const uploadProgress = document.getElementById('uploadProgress');

postBtn.addEventListener('click', async ()=>{
  const text = postText.value.trim();
  const files = postFiles.files;
  const user = auth.currentUser;
  if(!user) return alert('Not logged in');

  const post = {
    userId: user.uid,
    userName: user.displayName || user.email,
    text,
    media: [],
    likesCount: 0,
    commentsCount: 0,
    createdAt: serverTimestamp()
  };

  // upload files sequentially
  for(let i=0;i<files.length;i++){
    const file = files[i];
    const path = `posts/${user.uid}/${Date.now()}_${i}_${file.name}`;
    const sref = ref(storage, path);
    const task = uploadBytesResumable(sref, file);
    await new Promise((res,rej)=>{
      task.on('state_changed', snap => {
        const pct = Math.round((snap.bytesTransferred / snap.totalBytes)*100);
        uploadProgress.textContent = `Uploading: ${pct}%`;
      }, err => rej(err), async ()=>{
        const url = await getDownloadURL(sref);
        post.media.push({ url, type: file.type.startsWith('image') ? 'image' : 'video' });
        res();
      });
    });
  }

  uploadProgress.textContent = '';
  await addDoc(collection(db, 'posts'), post);
  postText.value=''; postFiles.value='';
});

// FEED (realtime)
function loadFeed(){
  const q = query(collection(db,'posts'), orderBy('createdAt','desc'));
  onSnapshot(q, snap=>{
    const feed = document.getElementById('feed');
    feed.innerHTML = '';
    snap.forEach(docSnap=>{
      const p = docSnap.data(); p.id = docSnap.id;
      const el = renderPost(p);
      feed.appendChild(el);
    });
  });
}

function renderPost(p){
  const div = document.createElement('div');
  div.className = 'post';
  const meta = document.createElement('div'); meta.className='meta';
  meta.innerHTML = `<div class="avatar"></div><div><b>${escapeHtml(p.userName)}</b><div class="small">${timeAgo(p.createdAt?.toDate?.()||new Date())}</div></div>`;
  div.appendChild(meta);
  const text = document.createElement('div'); text.innerHTML = `<p>${escapeHtml(p.text||'')}</p>`;
  div.appendChild(text);
  if(p.media && p.media.length){
    p.media.forEach(m=>{
      if(m.type==='image'){
        const img = document.createElement('img'); img.src = m.url;
        div.appendChild(img);
      } else {
        const vid = document.createElement('video'); vid.src = m.url; vid.controls=true; vid.style.maxWidth='100%';
        div.appendChild(vid);
      }
    });
  }

  // actions: like, comment, more
  const actions = document.createElement('div'); actions.className='actions';
  const likeBtn = document.createElement('button'); likeBtn.textContent = `Like (${p.likesCount||0})`;
  likeBtn.addEventListener('click', ()=> toggleLike(p));
  const commentBtn = document.createElement('button'); commentBtn.className='ghost'; commentBtn.textContent = `Comment (${p.commentsCount||0})`;
  commentBtn.addEventListener('click', ()=> openCommentBox(div, p));
  actions.append(likeBtn, commentBtn);
  div.appendChild(actions);

  return div;
}

async function toggleLike(post){
  const user = auth.currentUser;
  if(!user) return alert('Login first');
  const likeRef = doc(db, 'posts', post.id, 'likes', user.uid);
  const likeSnap = await getDoc(likeRef);
  const postRef = doc(db, 'posts', post.id);
  if(likeSnap.exists()){
    await deleteDoc(likeRef);
    await updateDoc(postRef, { likesCount: increment(-1) });
  } else {
    await setDoc(likeRef, { uid: user.uid, createdAt: serverTimestamp() });
    await updateDoc(postRef, { likesCount: increment(1) });
    await createNotification(post.userId, `${user.displayName || user.email} liked your post`, post.id);
  }
}

// comments
function openCommentBox(container, post){
  // simple comment UI appended under post
  let cb = container.querySelector('.comment-box');
  if(cb){ cb.remove(); return; }
  cb = document.createElement('div'); cb.className='comment-box';
  cb.innerHTML = `<input type="text" placeholder="Write comment..." class="commentInput"><button class="btnComment">Send</button><div class="commentsList small"></div>`;
  container.appendChild(cb);

  const postRef = doc(db,'posts',post.id);
  const input = cb.querySelector('.commentInput');
  cb.querySelector('.btnComment').addEventListener('click', async ()=>{
    const txt = input.value.trim(); if(!txt) return;
    await addDoc(collection(postRef,'comments'), { userId: auth.currentUser.uid, userName: auth.currentUser.displayName || auth.currentUser.email, text:txt, createdAt: serverTimestamp()});
    await updateDoc(postRef, { commentsCount: increment(1) });
    input.value = '';
    await createNotification(post.userId, `${auth.currentUser.displayName || auth.currentUser.email} commented on your post`, post.id);
  });

  // realtime comments
  const q = query(collection(postRef,'comments'), orderBy('createdAt','asc'));
  onSnapshot(q, snap => {
    const list = cb.querySelector('.commentsList');
    list.innerHTML = '';
    snap.forEach(s=>{
      const c = s.data();
      const div = document.createElement('div'); div.className='comment';
      div.innerHTML = `<b>${escapeHtml(c.userName)}</b> <div class="small">${escapeHtml(c.text)}</div>`;
      list.appendChild(div);
    });
  });
}

// suggestions (simple random users)
async function loadSuggestions(me){
  const usersSnap = await getDocs(query(collection(db,'users'), limit(5)));
  const suggestions = document.getElementById('suggestions');
  suggestions.innerHTML = '';
  usersSnap.forEach(u=>{ const d = u.data();
    const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.marginTop='8px';
    el.innerHTML = `<div><b>${escapeHtml(d.name)}</b><div class="small">${escapeHtml(d.bio||'')}</div></div>`;
    const btn = document.createElement('button'); btn.textContent='Follow'; btn.addEventListener('click', ()=> followUser(me.uid, d.uid));
    el.appendChild(btn);
    suggestions.appendChild(el);
  });
}

// follow
async function followUser(fromUid, toUid){
  if(fromUid===toUid) return;
  const followRef = doc(db, 'follows', `${fromUid}_${toUid}`);
  const snap = await getDoc(followRef);
  if(snap.exists()){
    await deleteDoc(followRef);
  } else {
    await setDoc(followRef, { fromUid, toUid, createdAt: serverTimestamp() });
    await createNotification(toUid, `You have a new follower`, null);
  }
}

// notifications for a user (simple)
async function createNotification(toUid, text, postId){
  if(!toUid) return;
  await addDoc(collection(db, 'notifications'), { toUid, text, postId: postId||null, from: auth.currentUser.uid, createdAt: serverTimestamp(), read:false });
}

function loadNotifications(user){
  const q = query(collection(db,'notifications'), where('toUid','==', user.uid), orderBy('createdAt','desc'));
  onSnapshot(q, snap=>{
    const out = document.getElementById('notifications');
    out.innerHTML = '';
    snap.forEach(s => {
      const n = s.data();
      const div = document.createElement('div'); div.className='small';
      div.innerHTML = `<div>${escapeHtml(n.text)} <div class="small">${timeAgo(n.createdAt?.toDate?.()||new Date())}</div></div>`;
      out.appendChild(div);
    });
  });
}

// stories: simple upload; expiry handled by client scheduled cleanup (production: server cron)
document.getElementById('storyFile').addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const p = `stories/${auth.currentUser.uid}/${Date.now()}_${file.name}`;
  const sref = ref(storage, p);
  await uploadBytesResumable(sref, file).then(async ()=>{
    const url = await getDownloadURL(sref);
    await addDoc(collection(db, 'stories'), { userId: auth.currentUser.uid, url, type: file.type.startsWith('image') ? 'image' : 'video', createdAt: serverTimestamp(), expiresAt: serverTimestamp() /* placeholder */});
  });
});

// helper functions
function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }
</script>
</body>
</html>
